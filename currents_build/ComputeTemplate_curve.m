% 'exoShape' is a derived software by Stanley Durrleman, Copyright (C) INRIA (Asclepios team), All Rights Reserved, 2006-2009, version 1.0
%--------------------------------------------------------------------------
% Based on MATCHINE v1.0 software.
% Copyright Université Paris Descartes
% Contributor: Joan Alexis GLAUNES (2006)
% alexis.glaunes@mi.parisdescartes.fr
% 
% This software is a computer program whose purpose is to calculate an optimal 
% diffeomorphic transformation in 3D-space that allows to match two datasets 
% like points, curves or surfaces.
% 
% This software is governed by the CeCILL-B license under French law and
% abiding by the rules of distribution of free software. You can use, 
% modify and/ or redistribute the software under the terms of the CeCILL-B 
% license as circulated by CEA, CNRS and INRIA at the following URL
% "http://www.cecill.info". 
% 
% As a counterpart to the access to the source code and rights to copy,
% modify and redistribute granted by the license, users are provided only
% with a limited warranty  and the software's author, the holder of the
% economic rights, and the successive licensors have only limited 
% liability. 
% 
% In this respect, the user's attention is drawn to the risks associated
% with loading, using, modifying and/or developing or reproducing the
% software by the user in light of its specific status of free software,
% that may mean that it is complicated to manipulate, and that also
% therefore means that it is reserved for developers and experienced
% professionals having in-depth computer knowledge. Users are therefore
% encouraged to load and test the software's suitability as regards their
% requirements in conditions enabling the security of their systems and/or 
% data to be ensured and, more generally, to use and operate it in the 
% same conditions as regards security. 
% 
% The fact that you are presently reading this means that you have had
% knowledge of the CeCILL-B license and that you accept its terms.
%--------------------------------------------------------------------------
  
% Any use of this code should make reference to:
% - S. Durrleman, X. Pennec, A. Trouve and N. Ayache, Statistical Models of Sets of Curves and Surfaces based on Currents, Medical Image Analysis, (2009), DOI: 10.1016/j.media.2009.07.007
% - J. Glaunes, A. Qiu, M. Miller, L. Younes, Large Deformation Diffeomorphic Metric Curve Mapping, International Journal of Computer vision, Springer, 2008, Vol. 80, No. 3, pp. 317--336, DOI: 10.1007/s11263-008-0141-9 



function TempL = ComputeTemplate_curve(data,grille,param,flag)

  %computes a template
  % for each subject suj, data.x{suj} is a 3-by-Nx matrix of point coordinates, data.vx{suj} is a 2-by-Nvx array, whose columns contain the indices in data.x{suj} of each segment of the curves, and data.wx{suj} is 1-by-Nvx array which gives the weight of each segment
  % grille contain the grid parameters:
  %   grille.long: size of the grid (3-by-one matrix)
  %   grille.pas: grid step
  %   grille.origine: coordinate of the bottom-left corner of the grid
  %   grille.fft3kd: FFT of the Gaussian Kernel (generated by Noyau3D_PAIR)
  %   
  % param contains the parameters
  % param.lambdaV: standard deviation of the Gaussian kernel for the deformations
  % param.gammaR: trade-off between regularity and fidelity to data for registrations
  % param.sigmaV = power before the Gaussian kernel for deformations
  % param.lambdaI = standard deviation of the Gaussian kernel for the currents.
  % 
  % flag is a string used to save results

%%%%%%%%%
% initialisations %
%%%%%%%%%
n_sujets = length(data.x);
data.c = cell(1,n_sujets);
data.N = cell(1,n_sujets);
for suj = 1:n_sujets
  [data.c{suj} data.T{suj}] = computeCentersTangents(data.x{suj},data.vx{suj},data.wx{suj});
end

% parametres du recalage %
lambdaW = param.lambdaW;
lambdaV = param.lambdaV;
gammaR = param.gammaR;
sigmaV = param.sigmaV;
lambdaW2 = lambdaW^2;
%parametre de l'approximation des courants
tau = 0.05;

paramStr = ['_lambdaV' num2str(lambdaV) '_lambdaW' num2str(lambdaW) '_gR' param.gRstr '_tau' num2str(100*(1-tau)) '_iter_'];

% parametres de la descente de gradient
stepmult = 1.2;
stepdiv = 2;
breakratio = 1e-4;
loopbreak = 10;
maxiterM = 20;

% parametres de la grille
nx = grille.long(1);
ny = grille.long(2);
nz = grille.long(3);

[x y z] = ndgrid(0:(nx-1),0:(ny-1),0:(nz-1));
x = x*grille.pas + grille.origine(1);
y = y*grille.pas + grille.origine(2);
z = z*grille.pas + grille.origine(3);
Gr = [x(:)';y(:)';z(:)'];


% calcul de l'ecart-type
etype = 0;
MoyC = [data.c{:}];
MoyT = [data.T{:}]/n_sujets;
for suj = 1:n_sujets
    auxC = cat(2,MoyC,data.c{suj});
    auxT = cat(2,MoyT,-data.T{suj});
    gamma = projConvol(auxT,auxC,grille.long,grille.pas,grille.origine,grille.fft3k_d);
    gammaN = sum(gamma.^2,4);
    etype = etype + max(gammaN(:));
end
etype = sqrt(etype/(n_sujets-1));
disp(['etype = ' num2str(etype)]);

% initialisation par le courant moyen %
gamma = projConvol(MoyT,MoyC, grille.long, grille.pas, grille.origine, grille.fft3k_d);
[TempL.x TempL.vx] = MatchingPursuit_curves(gamma,grille,tau,etype);
[TempL.x TempL.vx TempL.wx] = resizeDiracs1D(TempL.x, TempL.vx, lambdaW);
TempL.param = param;
save(['Faisceau_' num2str(flag) '_TemplateIteree_0.mat'],'TempL');


%%%%%%%%%%%%%%%%%%%%%%%%
% calcul de la moyenne par minimisation alternee %
%%%%%%%%%%%%%%%%%%%%%%%%
target = cell(1,1);
n_iter = 10;
for iter=1:n_iter

    disp(['iteration :' num2str(iter)]);

    %   STEP 1: Recalage de la moyenne sur chacune des instances
    if iter==1
        sujrange = 6;
    else
        sujrange = 1:n_sujets;
    end
    for suj=1:n_sujets
        clear s target

        s.sigmaV = lambdaV;
        s.stdV = sigmaV;
        s.gammaR = gammaR;
        s.rigidmatching = 0;
        s.numbminims = 1;
        s.optim_verbosemode = 1;
        s.x = TempL.x;
        s.usegrid = 1;
        s.ratio = .2;

        target{1}.method = 'curvecurr';
        target{1}.y = data.x{suj};
        target{1}.vy = data.vx{suj};
        target{1}.wy = data.wx{suj};
        target{1}.vx = TempL.vx;
        target{1}.wx = TempL.wx;
        target{1}.sigmaW = lambdaW;
        target{1}.usegrid = 1;
        target{1}.ratio = .2;
        s = match(s,target);
        fprintf('dist(id,phi)=%f    nNiter=%d\n',s.distIdPhi,length(s.J));

        % on sauve les matchings
        nom_fichier = ['Faisceau_' num2str(flag) '_matchingTemplateSurSujet_' num2str(suj) paramStr num2str(iter) '.mat'];
        save(nom_fichier,'s');
    end % FIN STEP 1
    
    diffeos = cell(1,n_sujets);
    for suj=1:n_sujets
        s = load(['Faisceau_' num2str(flag) '_matchingTemplateSurSujet_' num2str(suj) paramStr num2str(iter) '.mat']);
        s.s.optim_verbosemode = 0;
        diffeos{suj} = s.s;
    end

    %   STEP 2: Mise a jour de la moyenne pour chaque surface
    J = [];
    grad = computeGradient;
    gradN = sum(grad.^2,4);
    normeGrad2 = max(gradN(:));
    J(1) = computeFunct(TempL);
    stepsize = J(1)/normeGrad2/16;
    ok = 1;
    iterM = 1;
    disp([' stepsize : ' num2str(stepsize) '  functionnal : ' num2str(J(end))]);
    while(ok && (iterM<maxiterM))
        if (iterM > 1)
            grad = computeGradient;
        end
        % calcul du champ gamma associe au courant moyen
        [Tx Tnx] = computeCentersTangents(TempL.x,TempL.vx,TempL.wx);
        temp = projConvol(Tnx,Tx,grille.long,grille.pas,grille.origine,grille.fft3k_d);

        stepsize = stepsize * stepdiv;
        minimtest = 0;
        loop = 0;
        while(~minimtest && (loop<loopbreak))
            stepsize = stepsize / stepdiv;
            tempnew = temp - stepsize*grad;
            [TL_new.x TL_new.vx] = MatchingPursuit_curves(tempnew,grille,tau,etype);
            if (TL_new.x == -1)
                minimtest = 0;
                J(iterM+1) = -Inf;
            else
                [TL_new.x TL_new.vx TL_new.wx] = resizeDiracs1D(TL_new.x, TL_new.vx, lambdaW);
                J(iterM+1) = computeFunct(TL_new);
                minimtest = (J(iterM+1) < J(iterM));
            end
            loop = loop + 1;
            disp([' stepsize : ' num2str(stepsize) '  functionnal : ' num2str(J(end))]);
        end
        stepsize = stepsize * stepmult;
        if (loop~=loopbreak)
            TempL = TL_new;
            disp(['mise a jour du template : iteration ' num2str(iterM+1) '     functional = ' num2str(J(iterM+1)),...
             '     stepsize = ' num2str(stepsize)]);
        end
        ok = ( (J(iterM)-J(iterM+1)) > breakratio*(J(1)-J(iterM+1)) && loop~=loopbreak );
        iterM = iterM + 1;
    end %fin STEP 2

    filename = ['Faisceau_' num2str(flag) '_TemplateIteree_' num2str(iter) '.mat'];
    TempL.param = param;
    save(filename,'TempL');

end %fin iteration



  %%%%%%%%%%%%%%%%%%%
  % computeGradient %
  %%%%%%%%%%%%%%%%%%%
  function grad = computeGradient

   grad = zeros(nx,ny,nz,3);
   for sujet=1:n_sujets
     % deforms the template and substract the subject's line
     phiS = flow(diffeos{sujet},TempL.x,1,diffeos{sujet}.T);
     [cm taum] = computeCentersTangents(phiS,TempL.vx,TempL.wx);
     cx = [cm data.c{sujet}];
     taux = [taum (-data.T{sujet})];
     
     % deforms the grid
     diffeos{sujet}.usegrid = 1; diffeos{sujet}.ratio = 0.3; diffeos{sujet}.optim_verbosemode = 0;
     phiGrille = flow(diffeos{sujet},Gr,1,diffeos{sujet}.T);
     % computes the deformed gamma field
     grilleAux = setgrid(min([cx phiGrille],[],2),max([cx phiGrille],[],2),lambdaW,0.2);
     aux = gridOptim(cx,taux,phiGrille,grilleAux.long,grilleAux.pas,grilleAux.origine,grilleAux.fft3k_d);

     %multiplication par la jacobienne transposee
    for p=1:(nx*ny*(nz-1))
       pGX=phiGrille(1,p); pGY=phiGrille(2,p); pGZ = phiGrille(3,p);
       q = p+1;
       grad(p) = grad(p) + aux(1,p)*(phiGrille(1,q)-pGX) + aux(2,p)*(phiGrille(2,q)-pGY) + aux(3,p)*(phiGrille(3,q)-pGZ);
       q = p+nx;
       grad(p+nx*ny*nz) = grad(p+nx*ny*nz) + aux(1,p)*(phiGrille(1,q)-pGX) + aux(2,p)*(phiGrille(2,q)-pGY) + aux(3,p)*(phiGrille(3,q)-pGZ);
       q = p+nx*ny;
       grad(p + 2*nx*ny*nz) = grad(p + 2*nx*ny*nz) + aux(1,p)*(phiGrille(1,q)-pGX) + aux(2,p)*(phiGrille(2,q)-pGY) + aux(3,p)*(phiGrille(3,q)-pGZ);
    end
   end
   grad = 2*grad/grille.pas;
  end

  %%%%%%%%%%%%%%%%
  % computeFunct %
  %%%%%%%%%%%%%%%%
  function J = computeFunct(TL)
   J = 0;
   for sujet=1:n_sujets
    phiS = flow(diffeos{sujet}, TL.x, 1,diffeos{sujet}.T);
    [cm taum] = computeCentersTangents(phiS,TL.vx,TL.wx);
    cx = [cm data.c{sujet}];
    taux = [taum (-data.T{sujet})];
    nfx = size(cx,2);
    for p=1:nfx
     for q=1:nfx
      argin = -((cx(1,p)-cx(1,q))^2+(cx(2,p)-cx(2,q))^2+(cx(3,p)-cx(3,q))^2)/lambdaW2;
      argout = exp(argin);
      J = J + argout * (taux(1,p)*taux(1,q)+taux(2,p)*taux(2,q)+taux(3,p)*taux(3,q));
     end
    end
   end
  end

  function grille = setgrid(mini,maxi,sV,ratio)
        pas = ratio * sV; %grid's step
        long = (maxi-mini)/pas + 10/ratio; %circonf??rence du tore
        long = (long<=16)*16 + (long>16).*((long<=32)*32 + (long>32).*((long<=64)*64 + (long>64).*2.*ceil(long/2)));
        grille.pas = pas;
        grille.origine = mini - (long*pas-maxi+mini)/2;
        grille.long = long';
        grille.fft3k_d = noyau3D_PAIR(grille,sV);
  end

  function [cL tauL] = computeCentersTangents(Lx,Lvx,Lwx)
     nfx = size(Lvx,2);
     cL = zeros(3,nfx); %centers
     tauL = zeros(3,nfx); %tangents
     for k = 1:nfx
      b1 = 3*(Lvx(1,k)-1);
      b2 = 3*(Lvx(2,k)-1);
      cL(1,k) = (Lx(1+b1)+Lx(1+b2))/2;
      cL(2,k) = (Lx(2+b1)+Lx(2+b2))/2;
      cL(3,k) = (Lx(3+b1)+Lx(3+b2))/2;
      tauL(1,k) = Lwx(k)*(Lx(1+b2)-Lx(1+b1));
      tauL(2,k) = Lwx(k)*(Lx(2+b2)-Lx(2+b1));
      tauL(3,k) = Lwx(k)*(Lx(3+b2)-Lx(3+b1));
     end
  end

end






















